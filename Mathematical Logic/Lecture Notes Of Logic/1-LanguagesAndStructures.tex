\documentclass[9pt,a4paper, twocolumn]{article}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{url}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{graphicx, adjustbox}
\usepackage{lmodern}
\usepackage{fourier}
\usepackage{float}
\usepackage{caption}
\usepackage{wrapfig}
\usepackage{mhchem}
\usepackage{multicol}
\usepackage{soul}


\usepackage[top = 1cm, bottom = 1cm, left = 0.7cm, right = 0.7cm]{geometry}



%Colors
\usepackage[dvipsnames]{xcolor}


\definecolor{black}{RGB}{0, 0, 0}
\definecolor{richblack}{RGB}{7, 14, 13}
\definecolor{charcoal}{RGB}{45, 67, 77}
\definecolor{delectricblue}{RGB}{93, 117, 131}
\definecolor{cultured}{RGB}{245, 245, 245}
\definecolor{lightgray}{RGB}{211, 216, 218}
\definecolor{silversand}{RGB}{190, 194, 198}
\definecolor{spanishgray}{RGB}{148, 150, 157}
\definecolor{darkliver}{RGB}{64, 63, 76}

\colorlet{lightdelectricblue}{delectricblue!30}
\colorlet{lightdarkliver}{darkliver!30}


%ColorDefines
\newcommand{\trueblack}[1]{\textcolor{black}{#1}}
\newcommand{\rich}[1]{\textcolor{richblack}{#1}}
\newcommand{\lightblack}[1]{\textcolor{charcoal}{#1}}
\newcommand{\lightrich}[1]{\textcolor{delectricblue}{#1}}


%Boxes
\usepackage{tcolorbox}
\newtcolorbox{calloutbox}{center,%
    colframe =red!0,%
    colback=cultured,
    title={Callout},
    coltitle=richblack,
    attach title to upper={\ ---\ },
    sharpish corners,
    enlarge by=0.5pt}

\newtcolorbox[use counter=equation]{eq}{center,
	colframe =red!0,
	colback=cultured,
	title={\thetcbcounter},
	coltitle=richblack,
	detach title,
	after upper={\par\hfill\tcbtitle},
	sharpish corners,
    enlarge by=0.5pt }
    
\newtcolorbox{qt}{center,
	colframe=delectricblue,
	colback=white!0,
	title={\large "},
	coltitle=delectricblue,
	attach title to upper,
	after upper ={\large "},
	sharp corners,
	enlarge by=0.5pt,
	boxrule=0pt,
	leftrule=2pt}
	
\newtcolorbox{exc}{center,%
    colframe =red!0,%
    colback=darkliver!15,
    title={Excercise},
    coltitle=richblack,
    attach title to upper={\ ---\ },
    sharpish corners,
    enlarge by=0.5pt}
    
\newcounter{theo}
\newtcolorbox[use counter=theo]{theorem}
	{center,%
    colframe =red!0,%
    colback=cultured,
    title={Theorem \thetcbcounter},
    coltitle=richblack,
    attach title to upper={\ ---\ },
    sharpish corners,
    enlarge by=0.5pt}

\newcounter{defcounting}
\newtcolorbox[use counter=defcounting]{define}
{center,%
	colframe=darkliver!50,%
	colback=white!0,
	title={\textcolor{black}{\textbf{\textbf{Definition}} \  \thetcbcounter  \ --}},
	coltitle=darkliver!50,
	attach title to upper,
	after upper ={ },
	sharp corners,
	enlarge by=0.5pt,
	boxrule=0pt,
	leftrule=2pt,
    rightrule = 0pt}

\newcounter{lemmacount}
\newtcolorbox[use counter=lemmacount]{lemma}
{center,%
    colframe=charcoal!50,%
    colback=white!0,
    title={\textcolor{black}{\textbf{\textit{Lemma}} \  \thetcbcounter  \ --}},
    coltitle=darkliver!50,
    attach title to upper,
    after upper ={ },
    sharp corners,
    enlarge by=0.5pt,
    boxrule=2pt}
    

    \newcounter{propcount}
    \newtcolorbox[use counter=propcount]{proposition}
    {center,%
        colframe=charcoal!50,%
        colback=white!0,
        title={\textcolor{black}{\textbf{\textit{Proposition}} \  \thetcbcounter  \ --}},
        coltitle=darkliver!50,
        attach title to upper,
        after upper ={ },
        sharp corners,
        enlarge by=0.5pt,
        boxrule=2pt}
        
    \newcounter{colocount}
    \newtcolorbox[use counter=colocount]{corollary}
    {center,%
        colframe=charcoal!50,%
        colback=white!0,
        title={\textcolor{black}{\textbf{\textit{Corollary}} \  \thetcbcounter  \ --}},
        coltitle=darkliver!50,
        attach title to upper,
        after upper ={ },
        sharp corners,
        enlarge by=0.5pt,
        boxrule=2pt}
        
\newcounter{examplecounter}
\newtcolorbox[use counter=examplecounter]{example}
	{center,%
    colframe =red!0,%
    colback=cultured,
    title={Example},
    coltitle=richblack,
    attach title to upper={\ ---\ },
    sharpish corners,
    enlarge by=0.5pt}

    

        
    
% Highlighters
\newcommand{\hldl}[1]{%
	\sethlcolor{lightdarkliver}%
	\hl{#1}
}
\newcommand{\hldb}[1]{%
    \sethlcolor{lightdelectricblue}%
    \hl{#1}%
}


% Images
\newcounter{figurecounter}
\setcounter{figurecounter}{1}

\newcommand{\img}[3]{
    \begin{figure}[h!]
        \centering
        \captionsetup{justification=centering,margin=0cm,labelformat=empty}
        \includegraphics[width=#2\linewidth]{./img/#1}
        \label{figure}
        \caption{\small\textbf{fig-\thefigurecounter} -- \textcolor{darkliver}{#3}}
    \end{figure}
    \addtocounter{figurecounter}{1}}

\newcommand{\imgr}[3]{
    \begin{wrapfigure}{r}{#2\textwidth}
        \centering
        \captionsetup{justification=centering,margin=0cm,labelformat=empty}
        \includegraphics[width=\linewidth]{./img/#1}
        \label{figure}
        \caption{\small \textbf{fig: \thefigurecounter} -- \textcolor{darkliver}{#3}}
    \end{wrapfigure}
    \addtocounter{figurecounter}{1}}

\newcommand{\imgl}[3]{
    \begin{wrapfigure}{l}{#2\textwidth}
        \centering
        \captionsetup{justification=centering,margin=0cm,labelformat=empty}
        \includegraphics[width=\linewidth]{./img/#1}
        \label{figure}
        \caption{\small \textbf{fig: \thefigurecounter} -- \textcolor{darkliver}{#3}}
    \end{wrapfigure}
    \addtocounter{figurecounter}{1}}

% New commands
\newenvironment{callout}
	{\begin{calloutbox}\color{charcoal}\textbf\textit}
	{\end{calloutbox}}

% for this file
\newcommand{\newpoint}[1]{\ \\ \indent$\mathsection$ \textbf{#1}}
\newcommand{\curveL}{\mathcal{L}}
\newcommand{\curveA}{\mathcal{A}}
\newcommand{\curveP}{\mathcal{P}}
\newcommand{\thm}{\text{Thm}}
\newcommand{\proof}{\\ \ \\ $\blacktriangleright$ \textit{proof: }}
\newcommand{\distinct}{ \\ \hrule}


\title{Lectures On Mathematical Logic\\ \large Lecture One - Languages and Structures}
\date{\today}
\author{Amir H. Ebrahimnezhad \\ \small \textit{University of Tehran Department of Physics.}}

\parskip=12pt % adds vertical space between paragraphs


\begin{document}
    \maketitle
    \section*{Preface}
    The Lecture notes before you are followed from courses and books that have been read by me. I would try to work and update this every once in a while. This edition is updated until \today. For any question or corrections please contact me \textit{Thisismeamir@outlook.com}.
    \section*{Formal Languages}
        In logic, a formal language consists of words whose letters are taken from an alphabet and are well-formed according to a specific set of rules. In this context we construct a restricted formal language, and our goal is to be able to form a certain statements about certain kinds of mathematical structures.
        \begin{define}
            A \textbf{First-Order Language} $\curveL$ is an infinite collection of distinct symbols, no one of which is properly contained in another, separated into the following categories:
            \begin{enumerate}
                \item Parantheses: $(,)$.
                \item Connectives: $\lor, \neg$
                \item Quantifier: $\forall$
                \item Variables: One for each natural number $\rightarrow v_n$
                \item Equality symbol: $=$
                \item Constant symbols: Some set of zero or more symbols.
                \item Function symbols: For each positive integer $n$, some set of zero or more $n$-ary functions symbols.
                \item Relation symbols: For each positive integer $n$, some set of zero or more $n$-ary relation symbols.
            \end{enumerate}
        \end{define}
        \begin{callout}
            To say a function or a relation is $n$-ary, means that it is intended to represent a function or relation of $n$ variables.
        \end{callout}
        \begin{callout}
            To specify a language, all we have to do is to determine which, if any, constant, function, and relation symbols we wish to use.
        \end{callout}
        \newpoint{Formulas and Terms:} Suppose a language $\curveL = \left\{v, + , <\right\}$. Any combination of these elements are said to be a word in that language, but not all the combinations are pleasing. For instance:
        $$
        v + v < (v + v) + v
        $$
        and 
        $$
        v ++<v
        $$
        are both words in the laguage we made but one would argue that the latter has no meaning and thus is of no interest for us. Therefore we would start defining some meaningful words for our language:
        \begin{define}
            If $\curveL$ is a language, \textbf{a term of $\curveL$} is a nonempty finite string $t$ of symbols from $\curveL$ such that either:
            \begin{enumerate}
                \item $t$ is a variable, or
                \item $t$ is a constant symbol, or
                \item $t:\equiv ft_1t_2t_3\dots t_n$ where $f$ is an $n$-ary function symbol of $\curveL$ and each of the $t_i$ is a term of $\curveL$
            \end{enumerate}
            \
        \end{define}
        \begin{callout}
            The symbol $:\equiv$ is not a part of strings of the language $\curveL$. Rather it is a meta-linguistic symbol that means that the strings of $\curveL$-symbols on each side of it are identical.
        \end{callout}
        The terms of $\curveL$ play the role of the nuons of the language. To make meaningful mathematical statements about some mathematical structure, we will want to be able to make assertions about the objects of the structure. These assertions will be the formulas of $\curveL$:
        \begin{define}
            If $\curveL$ is a first-order language, \textbf{a formula of $\curveL$} is a noneempty finite string $\phi$ of symbols from $\curveL$ such that either:
            \begin{enumerate}
                \item $\phi:\equiv = t_1t_2$ where $t_i$ is a term in $\curveL$, or
                \item $\phi:\equiv Rt_1t_2\dots t_n$ where $R$ is an $n$-ary relation and $t_i$s are terms in $\curveL$, or
                \item $\phi :\equiv (\neg\alpha)$ where $\alpha$ is a formula of $\curveL$, or
                \item $\phi:\equiv (\alpha\lor\beta)$, where $\alpha, \beta$ are formulas of $\curveL$
                \item $\phi:\equiv (\forall v)(\alpha)$, where $v$ is a variable and $\alpha$ is a formula of $\curveL$.
            \end{enumerate}
        \end{define}
        If a formula $\psi$ contains the subformula $\forall v \alpha$ [meaning that the string of symbols that constitute the formula is a substring of the string of symbols that make up $\psi$], we will say that the \textbf{scope} of the quantifier $\forall$ is $\alpha$. Any symbols in $\alpha$ will be said to lie within the scope of the quantifier $\forall$.
        \begin{callout}
            Notice that a firmula can have several different occurrences of the symbol $\forall$, and each occurrence of the quantifier will have its own scope.
        \end{callout}
        The \textbf{Atomic Formulas of $\curveL$} are those formulas that satisfy clause (1) or (2) of the definition. Also note that the terms of a language are not formulas. In addition to the similarities between terms and nouns, formulas are statements in the language. Statements unlike nouns can be true or false. 
        \newpoint{Induction:} We already used induction in many high school mathematics. It is now our goal to discuss the proofs by induction using the language, formulas, and terms we learned and generalize that notion of induction to a setting that will allow us to use induction to prove things about terms and formulas rather than just the natural numbers:
        \\
        \\
        In the inductive step of the proof, we show the following implication:
        \begin{center}
            If the formula holds for $k$, then the formula holds for $k+1$
        \end{center}
        We prove this implication by assuming the antecedent, that the theorem holds for a number $k$, and from that assumption we show that it also holds for $k+1$. Notice that the formula itself is universal, means it is for all $k$s but here we only assume a certain $k$, therefore we are not assuming the theorem itself. Looking at this from another way we've shown that for a set $S$ of numbers that holds the theorem true, there is these facts:
        \begin{enumerate}
            \item The number $1$ is an element of $S$. We prove this explicitly in the base case of the proof.
            \item If the number $k$ is an element of $S$, then the number $k+1$ is also an element of $S$. (This is the inductive step)
        \end{enumerate}
        But now, notice that we know that the collection of natural numbers can be defined as the smallest set such that the facts above implise, but it is not always the largest. So $S$, the collection of numbers which the theorem holds, is identical with the set of natural numbers, thus the theorem holds for every natural number $n$, as needed. So what makes the proof by induction work is that the natural numbers can be defined recursively. This is an important thing!
        \\
        \\
        Looking at the definition of the formula the first two clauses has the role of (1)st fact about the set $S$ we had here. They are explicitly defined. The last three clauses are the recursive cases, showing how if $\alpha, \beta$ are a formula, we can generate more formulas with those. Now since the collection of formulas is defined recursivelym we can use an inductive-style proof when we want to prove that something is true about every formula! The proof is consist of showing that (1) The theorem holds for every atomic formula. (2) In the inductive phase of the proof, we assume that the theorem is true about simple formulas ($\alpha,\beta$) amd use that assumption to prove that the theorem holds a more complicated formula $\phi$ that is generated by a recursive clause of the definition. This method of proof is called \textit{Induction on the complexity of the formula,} or \textit{Induction on the structure of the formula.}
        \newpoint{Sentences:} Assume the language of number theory $\curveL_{NT} = \left\{0, S, +, \cdot, E, <\right\}$, and consider the following formulas:
        \begin{align*}
            \neg(\forall x)[(x<y)\lor(x=y)] \\ 
            (\forall x)(\forall y)[(x<y)\lor(x=y)\lor(y<x)]
        \end{align*}
        The second formula is true, for all of the replacements of $x$ and for all $y$, but the truth of the first statement, is rather indetermined. For some numbers of $x,y$ the formula holds and for others it does not. The formulas of $\curveL$ fall into two classes: The Sentences such as the second formula, and the non-sentences. To begin we would start from defining a free-variable.
        \\
        \\
        We define a free-variable as a variable that the truth of a formula depends on it. More precisely:
        \begin{define}
            Suppose that $v$ is a variable and $\phi$ is a formula. We will say that $v$ \textbf{is free in $\phi$} if:
            \begin{enumerate}
                \item $\phi$ is atomic and $v$ occurs in $\phi$, or
                \item $\phi:\equiv (\neg\alpha)$ and $v$ is free in $\alpha$, or
                \item $\phi:\equiv (\alpha\lor\beta)$ and $v$ is free in either $\alpha$ or $\beta$, or
                \item $\phi:\equiv (\forall u)(\alpha)$ and $v$ is not $u$ and is free in $\alpha$.
            \end{enumerate}
        \end{define}
        And so:
        \begin{define}
            A \textbf{Sentence} in a language $\curveL$ is a formula of $\curveL$ that contains no free variable.
        \end{define}

    \section*{Structures}
        For the language of number thoery, as an exmaple, it is certainly true that you know an interpretation for the symbols in that language, where $S$ is the map that takes $x$ to $x+1$ and $E$ is exponentiation function, 0 represents number zero and so on. The point here is that there are many different possible interpretations for these symbols, and we want to be able to specify which of those interpretations is the one we are talking about. There is nothing sacred about oe mathematical structure as opposed to another. Without determining the structure under consideration, without deciding how we wish to interpret the symbolsof the language, we have no way of talking abou the truth or falsity of any sentence, even the trivial ones:
        \begin{define}
            Fix a language $\curveL$. An $\curveL$-Structure $\curveA$ is a nonempty set $A$, called \textbf{the universe of} $\curveA$, together with:
            \begin{enumerate}
                \item For each constant symbol $c$ of $\curveL$, an element $c^\curveA$ of $A$.
                \item For each $n$-ary function symbol of $\curveL$, a function $f^\curveA: A^n \rightarrow A$
                \item For each $n$-ary relation symbol of $\curveL$, an $n$-ary relation $R^\curveA$ on $A$.
            \end{enumerate}
        \end{define}
        \newpoint{Truth in a Structure}
            We have some formal rules about what constitutes a language, and we can identify the terms, formulas, and sentences of a language. We can also identify $\curveL$-structures for a give language $\curveL$. Now we will decide what is means to say that an $\curveL$-formula is true in an $\curveL$-structure.
            \begin{define}
                If $\curveA$ is an $\curveL$-structure, a \textbf{variable assignment function into $\curveA$} is a function $s$ that assigne to each variable and element of the universe $A$. So a variable assignment function into $\curveA$ is any function with doman $Vars$ and Codomain $A$.
            \end{define}
            These assignment functions will formalize what it means to interpret a term or a formula in a structure. We will occasionally want to fix the value of the assignment function $s$ for a certain set of variables:
            \begin{define}
                If $s$ is a variable assignment function into $\curveA$ and $x$ is a variable and $a \in A$, then $s[x|a]$ is the variable assignment function into $\curveA$ defined as:
                \begin{equation}
                    s[x|a] = \left\{ \begin{matrix} s(v) & \text{if } $v$ \text{ is a variable other than } x.\\ a & \text{if } v \text{is the variable }x.\end{matrix}\right.
                \end{equation}
                We call this function an $x$\textbf{-modification of the assignment function} $s$. It is the same as $s$, but a certain variable $x$ is assigned to a certain element of the universe $A$.
            \end{define}
            Now we would generalize this to a term assignment function.
            \begin{define}
                Suppose that $\curveA$ is an $\curveL$-structure and $s$ is a variable assignment function into $\curveA$. The function $\bar s$, called the \textbf{term assignment function generated by $s$}, is the function with domain consisting of the set of $\curveL$-terms and codomain $A$ defined recursively as follows:
                \begin{enumerate}
                    \item if $t$ is a variable, $\bar s(t) = s(t)$.
                    \item if $t$ is a constant symbol $c$, $\bar s(t) = c^\curveA$.
                    \item if $t:\equiv ft_1t_2\dots t_n$ then $\bar s(t) = f^\curveA(\bar s(t_1),\bar s(t_2),\dots, \bar s(t_n))$
                \end{enumerate}
            \end{define}
            Now we will describe truth (or satisfaction) for arbitrary formulas, relative to an assignment function. 
            \begin{define}
                Suppose that $\curveA$ is an $\curveL$-structure, $\phi$ is an $\curveL$-formula, and $s: Vars\rightarrow A$ is an assignment function. We will say that $\curveA$ satisfier $\phi$ with assignment$s$, and write $\curveA \vDash \phi[s]$ in the following circumstances:
                \begin{enumerate}
                    \item If $\phi:\equiv t_1t_2$ and $\bar s(t_1)$ is the same element of the universe $A$ as $\bar s(t_2)$, or
                    \item If $\phi:\equiv Rt_1\dots t_n$ and $(\bar s(t_1) \dots \bar s(t_n)) \in R^\curveA$, or
                    \item If $\phi:\equiv (\neg\alpha)$ and $\curveA\not\vDash \alpha[s]$, or
                    \item If $\phi:\equiv (\alpha\lor\beta)$ and $\curveA\vDash\alpha[s]$ or $\curveA\vDash\beta[s]$ (or both), or
                    \item If $\phi:\equiv (\forall x)(\alpha)$ and for each $a\in A$, $\curveA\vDash \alpha[s(x|a)]$.
                \end{enumerate}
            \end{define}
            And if we have a set of formulas $\Gamma$, we say that $\curveA\vDash \Gamma[s]$ if for each formula $\gamma$ in $\Gamma$, $\curveA\vDash\gamma$. Now to talk about truth or falsity of a sentence in a structure, we will take our definition of satisfaction relative to an assignment function and prove that for sentences, the choice of the assignement function is inconsequential. Then we'll have shown that a sentence is true in a structure if and only if for any (therefore for all) choice of assignment function it is satisfied in structure. Here we need a lemma and a proposition but the proof of which is lend to the reader + The context is borrowed from the book \textit{Friendly Introduction to Mathematical Logic} and therefore one can check the page 30 for proofs.
            \begin{lemma}
                Suppose that $s_1$ and $s_2$ are variable assignment functions into a structure $\curveA$ such that $s_1(v)= s_2(v)$ for every variable $v$ in the term $t$. Then $\bar s_1(t) = \bar s_2(t)$.
            \end{lemma} 
            \begin{proposition}
                Suppose that $s_1$ and $s_2$ are variable assignment functions into a structure $\curveA$ such that $s_1(v)= s_2(v)$ for every free variable $v$ in the formula $\phi$. Then $\curveA\vDash \phi[s_1]$ if and only if $\curveA\vDash \phi[s_2]$.
            \end{proposition}
            \begin{corollary}
                If $\sigma$ is a sentence in the language $\curveL$ and $\curveA$ is a structure of the language, either $\curveA\vDash \sigma[s]$ for all assignment functions or for no assignment function.
            \end{corollary}
            And lastly we would define models:
            \beign{define}
                If $\phi$ is a formula in the language $\curveL$ and $\curveA$ is an $\curveL$-structure, we say that $\curveA$ is a model of $\phi$, and write $\curveA\vDash \phi$ if and only if $\curveA\vDash\phi[s]$ for every assignment function $s$. 
            \end{define}
            Notice that if $\sigma$ is a sentence, then $\curveA\vDash\sigma$ if and only if it is so in every possible assignment function $s$. In such a case we would say that the sentence is true in $\curveA$.
    \section*{Substitution and Substitutability}
        \newpoint{Substitution:}
            Suppose that $\curveA\vDash \forall x\exists y\neg(x=y)$. This sentence is, in fact, true in any structure $\curveA$ such that $A$ has at least two elements. If we then proceed to replace the variable $x$ by variable $u$, we get the statement $\exists y\neg(u=y)$, which will still be true in $\curveA$ , no matter what value we give to the variable $u$. however if we take the formula and replace $x$ by $y$ then we got: $\exists y\neg(y=y)$, which will be false in any structure. So by a poor choice of substituting variable, we have changed the truth values of out formula. The rules of substitutability that we will discuss in this section are designed to help us avoid this problem, the problem of attemptint to substitute a term inside a quantifier that binds a variable that involved in the term.
            \begin{define} 
                Suppose that $u$ is a term, $x$ is a variable and $t$ is a term in language $\curveL$. We define the term $u^x_t$ (read $u$ with $x$ replaced by $t$) as follows:
                \begin{enumerate}
                    \item If $u$ is a variable not equal to $x$ then $u^x_t$ is $u$,
                    \item If $u$ is $x$ then $u^x_t$ is $t$,
                    \item If $u$ is a constant symbol, then $u^x_t$ is $u$,
                    \item If $u:\equiv fu_1u_2\dots u_n$ then  $u^x_t :\equiv f(u_1)^x_t(u_2)^x_t\dots(u_n)^x_t$.
                \end{enumerate}
            \end{define}
            And also for formulas:
            \begin{define}
                Suppose that $\phi$ is a formula in the langauge, $t$ is a term and $x$ is a variable. We define formula $\phi_t^x$ (read the formula $\phi$ with $x$ replaced by $t$) as follows:
                \begin{enumerate}
                    \item If $\phi:\equiv =u_1u_2$ then $\phi_t^x:\equiv = (u_1)_t^x(u_2)_t^x$.
                    \item If $\phi:\equiv Ru_1\dots u_n$ then $\phi_t^x :\equiv R(u_1)_t^x\dots (u_n)_t^x$.
                    \item If $\phi:\equiv \neg(\alpha)$ then $\phi_t^x:\equiv \neg(\alpha_t^x)$.
                    \item If $\phi:\equiv (\alpha\lor\beta)$ the $\phi_t^x$ is $(\alpha_t^x\lor\beta_t^x)$.
                    \item If $\phi:\equiv (\forall y)(\alpha)$ then:
                    $$
                    \phi_t^x = \left\{ \begin{matrix} \phi & x = y \\ (\forall y)(\alpha_t^x) &\text{otherwise}\end{matrix} \right.
                    $$
                \end{enumerate}
            \end{define}
            Having defined what we mean when we substitute a term for a variable, we will now define what it means for a term to be substitutable for a variable in a formula. The idea is that if $t$ is substitutable for $x$ in $\phi$, we will not run into the problems discussed at the beginning of this section. We will not substitute a term in such a way that a variable contained in that term is inadvertently bound by a quantifier.
            \begin{define}
                Suppose $\phi$ is an $\curveL$-formula, $t$ is a term, and $x$ is a variable. We say that $t$ is substitutable for $x$ in $\phi$ if:
                \begin{enumerate}
                    \item $\phi$ is atomic, or
                    \item $\phi:\equiv \neg(\alpha)$ and $t$ is substitutable in $\alpha$, or
                    \item $\phi:\equiv (\alpha\lor\beta)$ and $t$ is substitutable for $x$ in both $\alpha$ and $\beta$, or
                    \item $\phi:\equiv (\forall y)(\alpha)$ and either $x$ is not free in $\phi$ or $y$ does not occur in $t$ and $t$ is substitutable for $x$ in $\alpha$.
                \end{enumerate}
            \end{define}
        \newpoint{Logical Implication: } 
                At first glance it seems that a large portion of mathematics can be broken down into answering questions of the form: If you know such statement is true, is it the case that this other statement is also true? In this point we would formalize this question:
                \begin{define}
                    Suppose that $\Delta$ and $\Gamma$ are setes of $\curveL$-formulas. We will say that $\Delta$ logically implies $\Gamma$ and write $\Delta\vDash\Gamma$ if for every $\curveL$-structure $\curveA$, if $\curveA\vDash\Delta$, then $\curveA\vDash\Gamma$.
                \end{define}
                This definition is a little bit tricky. It says that if $\Delta$ is true in $\curveA$, then $\Gamma$ is true in $\curveA$. 
                \begin{define}
                    An $\curveL$ formula $\phi$ is said to be vaild if $\not0\vDash\phi$, in other words, if $\phi$ is true in every structure of language with every assignment function $s$. In this case, we will write $\vDash \phi$.

\end{document}